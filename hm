#!/usr/bin/python

import glob
import importlib
import os
import pwd
import re
import sys



class ERROR_CODE:
    SUCCESS = 0

    # Python uses exit-code 1 as a generic exit-code during exceptions.
    # We want to avoid using this exit-code in our code.
    GENERIC_EXCEPTION = 1

    INVALID_INPUT = 2
    PLUGIN_FAILED = 3
    WRITE_FAILED = 4
    USER_ABORTED = 5
    FILE_NOT_FOUND = 6
    CANNOT_PROCESS_HOSTS_FILE = 7


class Version:
    MAJOR = 0
    MINOR = 1
    PATCH = 0
    META = ''

    @classmethod
    def get(cls):
        version = str(cls.MAJOR) + \
                  '.' + str(cls.MINOR) + \
                  '.' + str(cls.PATCH)

        if len(cls.META) > 0:
            version += '-' + cls.META

        return version


# constants - START

VERSION = Version.get()

SUPPORTED_ARGS = (
    '-v',
    '--version',

    'build',
    'clean',
    'clean-all'
)

USER_ID = os.getuid()
USER_NAME = pwd.getpwuid(USER_ID).pw_name

# get the command line input arguments into a var
INPUT_ARGS = sys.argv
INPUT_ARGS_COUNT = len(INPUT_ARGS)
PRIMARY_COMMAND = INPUT_ARGS[1]

SCRIPT_NAME = INPUT_ARGS[0]
SCRIPT_PATH = os.path.realpath(SCRIPT_NAME)
SCRIPT_DIR = os.path.dirname(SCRIPT_PATH)

CONFIG_FILE_NAME = 'config.py'

# constants - END


# methods - START

def print_valid_args():
    print "\nValid arguments are:\n%s" % '\n'.join(SUPPORTED_ARGS)


def verify_supported_args():
    unsupported_args = []

    if INPUT_ARGS_COUNT <= 1:
        print 'No arguments supplied'
        print_valid_args()
        sys.exit(ERROR_CODE.INVALID_INPUT)

    if INPUT_ARGS_COUNT > 2:
        print 'Too many arguments supplied'
        print_valid_args()
        sys.exit(ERROR_CODE.INVALID_INPUT)

    for i in range(1, INPUT_ARGS_COUNT):
        arg = str(INPUT_ARGS[i])

        if not arg in SUPPORTED_ARGS:
            unsupported_args.append(arg)

    if len(unsupported_args) > 0:
        print "Invalid input. The following arguments are not supported:\n%s" % '\n'.join(unsupported_args)
        print_valid_args()
        sys.exit(ERROR_CODE.INVALID_INPUT)


def import_module_from_file(file_name):
    module_name = re.sub('\.py', '', file_name)
    module_name = re.sub('/', '.', module_name)

    module = importlib.import_module(module_name)

    return module


def load_config():
    if not os.path.isfile(CONFIG_FILE_NAME):
        print 'Config file not found - Aborting'
        sys.exit(ERROR_CODE.FILE_NOT_FOUND)

    config = import_module_from_file(CONFIG_FILE_NAME)
    print 'Config file loaded\n'
    return config


def load_host_maps():
    host_map_files = glob.glob('hosts_maps/*_conf.py')

    print 'Loading host-map files:'

    for host_map_file in host_map_files:
        print "\t%s" % host_map_file
        module = import_module_from_file(host_map_file)
        for map_key, host_map_dict in module.host_map_config.items():
            add_host_map(map_key, host_map_dict)

    print "Done - %s file(s) loaded\n" % len(host_map_files)

    return


def load_plugins():
    active_plugins = config.active_plugins

    print 'Active-plugins:'

    for plugin_name in active_plugins:
        print "\t%s" % plugin_name

    print "%s plugin(s) active\n" % len(active_plugins)

    for plugin_name in active_plugins:
        print "Running: '%s'" % plugin_name

        plugin_config = {}

        if plugin_name in config.plugin_config:
            plugin_config = config.plugin_config[plugin_name]

        try:
            plugin = import_module_from_file("plugins/%s/main.py" % plugin_name)

            print "%s v%s" % (plugin.DISPLAY_NAME, plugin.VERSION)

            host_map_dict = plugin.main(plugin_config)

            add_host_map(plugin_name, host_map_dict)

        except Exception, err:
            print "\t%s\nFailed\n" % err
            sys.exit(ERROR_CODE.PLUGIN_FAILED)
        else:
            print "Done\n"

    return


def add_host_map(map_key, host_map_dict):
    curr_host_map = {}

    if map_key in host_map:
        curr_host_map = host_map[map_key]

    for ip, host_names in host_map_dict.items():
        ip_map = []

        if ip in curr_host_map:
            ip_map = curr_host_map[ip]

        for host in host_names:
            if not host in ip_map:
                ip_map.append(host)

        curr_host_map[ip] = ip_map

    host_map[map_key] = curr_host_map
    return curr_host_map


def read_hosts_file():
    hosts_file = []
    print "Reading hosts file at:\n\t%s" % config.hosts_file_path

    with open(config.hosts_file_path, "r") as f:
        hosts_file = f.readlines()

    print 'Done\n'

    return hosts_file


def cannot_process_hosts_file():
    # For some reason or the other the input
    # hosts file could not be processed.
    # Show an error to the user and abort.
    print "\nThe input hosts file does NOT have the correct order of 'tkhm' delimiters."
    print "Cannot process further. Aborting!\n"
    sys.exit(ERROR_CODE.CANNOT_PROCESS_HOSTS_FILE)


def clean_hosts_file(clean_all=False):
    print 'Cleaning hosts file'

    if clean_all:
        print '\tClean all = Y\n'
        print '\tTHIS WILL CLEAR THE HM HOSTS-CONFIG FOR ALL USERS.'

        confirm = None

        try:
            # python 2.7+
            confirm = raw_input('\tAre you sure you want to do this? [y/N] ')
        except Exception:
            # python 3+
            confirm = input('\tAre you sure you want to do this? [y/N] ')

        if confirm.lower() != 'y':
            print '\nAborted by the user!\n'
            sys.exit(ERROR_CODE.USER_ABORTED)


    global hosts_file

    cleaned_hosts_file = []
    write = True
    skip_blank_lines = False
    pattern = None

    if clean_all:
        pattern = "^# tkhm - .*? - (START|END)$"
    else:
        pattern = "^# tkhm - %s - (START|END)$" % USER_NAME


    for i in range(0, len(hosts_file)):
        line = hosts_file[i]

        match = re.match(pattern, line)

        if match:
            if (match.group(1) == 'START' and not write) \
                or (match.group(1) == 'END' and write):
                # The delimiters are screwed up; abort
                cannot_process_hosts_file()


            if write:
                while len(cleaned_hosts_file) > 0 and re.sub('[\s\n]+', '', cleaned_hosts_file[-1]) == '':
                    cleaned_hosts_file.pop()

                # leave a courtesy new-line
                cleaned_hosts_file.append('\n')
            else:
                skip_blank_lines = True

            write = not write
            continue

        if skip_blank_lines and re.sub('[\s\n]+', '', line) == '':
            continue

        skip_blank_lines = False

        if not write:
            continue

        cleaned_hosts_file.append(line)

    if not write:
        # This shouldn't happen.
        # Once the END delimiter is reached the flag is switched
        # to 'write = True' again.
        # This means the delimiters are screwed up; abort
        cannot_process_hosts_file()

    hosts_file = cleaned_hosts_file

    try:
        with open(config.output_file_path, "w") as f:
            f.write(
                ''.join(hosts_file)
            )

    except Exception, err:
        print "\t%s\nFailed\n" % err
        sys.exit(ERROR_CODE.WRITE_FAILED)
    else:
        print "Done\n"

    return


def write_hosts_file():
    global hosts_file

    hosts_count = 0

    hosts_file += [
        '\n\n\n',
        "# tkhm - %s - START\n" % USER_NAME
    ]


    for (key, curr_host_map) in host_map.items():
        curr_hosts_list = []

        for (ip, host_names) in curr_host_map.items():
            curr_host_count = len(host_names)

            if curr_host_count == 0:
                continue

            hosts_count += curr_host_count

            ip_length = len(ip)

            tabs = '\t'

            # calculate tabs assuming ipv4 mapping
            if ip_length < 8:
                tabs *= 3
            elif ip_length < 12:
                tabs *= 2

            curr_hosts_list += [ "%s%s%s\n" % (ip, tabs, ' '.join(host_names)) ]

        if len(curr_hosts_list) > 0:
            hosts_file += [
                '\n\n',
                "# %s - START\n" % key,
                '\n'
            ]

            hosts_file += curr_hosts_list

            hosts_file += [
                '\n',
                "# %s - END\n\n" % key
            ]


    hosts_file += [
        '\n',
        "# tkhm - %s - END\n" % USER_NAME,
        '\n\n'
    ]


    if hosts_count == 0:
        print 'Host map is empty. Nothing to do!\nExiting'
        sys.exit(ERROR_CODE.SUCCESS)

    print "Writing hosts file:\n\t%s" % config.output_file_path

    try:
        with open(config.output_file_path, "w") as f:
            f.write(
                ''.join(hosts_file)
            )

    except Exception, err:
        print "\t%s\nFailed\n" % err
        sys.exit(ERROR_CODE.WRITE_FAILED)
    else:
        print "Done\n"

    return

# methods - END


# regular program from this point on

config = None
host_map = {}
hosts_file = None


# need to do this in-case the executable is symlinked
os.chdir(SCRIPT_DIR)


verify_supported_args()


if PRIMARY_COMMAND in ('-v', '--version'):
    print VERSION
    sys.exit(ERROR_CODE.SUCCESS)


print "TK host manager v%s\n" % VERSION


config = load_config()

load_host_maps()

hosts_file = read_hosts_file()



if PRIMARY_COMMAND == 'clean-all':
    clean_hosts_file(True)
    sys.exit(ERROR_CODE.SUCCESS)


clean_hosts_file()


if PRIMARY_COMMAND == 'clean':
    # already done cleaning; exit
    sys.exit(ERROR_CODE.SUCCESS)

if PRIMARY_COMMAND != 'build':
    # We shouldn't be here if the `verify_supported_args` method
    # did it's job correctly but since we are here, exit with an
    # error code.
    sys.exit(ERROR_CODE.INVALID_INPUT)


# only executing the `build` command from here on out

load_plugins()
write_hosts_file()

sys.exit(ERROR_CODE.SUCCESS)
